# Árvore 2-3-4 (B-Tree de Ordem 2)

## O que é uma Árvore 2-3-4?

A Árvore 2-3-4 (também conhecida como B-Tree de ordem 2) é uma árvore de busca **auto-balanceada** onde cada nó pode conter entre 1 e 3 chaves e ter entre 2 e 4 filhos. Foi inventada por Rudolf Bayer em 1970 e é a base teórica dos B-Trees modernos, amplamente utilizados em sistemas de banco de dados e sistemas de arquivos.

A estrutura 2-3-4 é especialmente interessante porque oferece uma alternativa elegante às Red-Black Trees, com uma característica fundamental: **toda a complexidade do rebalanceamento é evitada através da divisão de nós cheios durante a inserção**, em vez de realizar rotações múltiplas.

## Propriedades Fundamentais

Uma Árvore 2-3-4 deve satisfazer as seguintes propriedades:

1. **Tipos de Nós**:
   - **Nó-2**: Contém 1 chave e 2 filhos (ou é folha)
   - **Nó-3**: Contém 2 chaves e 3 filhos (ou é folha)
   - **Nó-4**: Contém 3 chaves e 4 filhos (ou é folha)

2. **Propriedade de Busca**: As chaves em cada nó estão ordenadas e valores entre chaves obedecem a invariante de BST

3. **Propriedade de Balanceamento Perfeito**: Todos os caminhos da raiz até qualquer folha têm exatamente o mesmo comprimento

4. **Propriedade de Preenchimento**: Cada nó (exceto raiz) contém pelo menos 1 chave (é um nó-2 no mínimo)

5. **Propriedade de Overflow Prevention**: Nenhum nó pode conter mais de 3 chaves (se tentar, divide-se em dois)

## Estrutura do Nó

```python
class BTreeNode:
    def __init__(self, t=2, leaf=True):
        self.keys = []              # Lista de chaves (1 a 3 chaves)
        self.children = []          # Lista de filhos (2 a 4 filhos)
        self.leaf = leaf            # True se é folha
        self.n = 0                  # Número atual de chaves
        self.t = t                  # Grau mínimo (para 2-3-4, t=2)
```

Cada nó mantém:
- `keys`: Lista ordenada de valores armazenados
- `children`: Ponteiros para os nós filhos
- `leaf`: Flag indicando se é uma folha
- `n`: Número de chaves atualmente armazenadas

## Comparação com Outras Estruturas

| Estrutura | Busca | Inserção | Remoção | Altura | Nós Balanceados |
|-----------|-------|----------|---------|--------|-----------------|
| BST | O(n) | O(n) | O(n) | O(n) | ❌ |
| AVL Tree | O(log n) | O(log n) | O(log n) | O(log n) | ✅ |
| Red-Black Tree | O(log n) | O(log n) | O(log n) | O(log n) | ✅ |
| **Árvore 2-3-4** | **O(log n)** | **O(log n)** | **O(log n)** | **O(log n)** | **✅** |
| B-Tree (grau maior) | O(log n) | O(log n) | O(log n) | O(log n) | ✅ |

## Por que usar Árvore 2-3-4?

### Vantagens
- **Balanceamento Perfeito**: Altura = O(log n) garantida
- **Inserção Elegante**: Divisão de nós ao invés de rotações complexas
- **Rebalanceamento Simples**: Menos casos especiais que Red-Black Tree
- **Remoção Previsível**: Merging de nós é mais intuitivo
- **Base Teórica de B-Trees**: Fundamento para sistemas reais de banco de dados
- **Visualização Intuitiva**: Facilita compreensão de conceitos de balanceamento

### Desvantagens
- **Mais Complexa que BST**: Requer lógica de splitting/merging
- **Mais Nós por Percurso**: Mais operações por busca comparado a árvores binárias
- **Cache Menos Eficiente**: Mais comparações por nó que Red-Black Tree

## Operações e Complexidade

| Operação | Complexidade | Descrição |
|----------|--------------|-----------|
| **Inserção** | O(log n) | Adiciona elemento com divisão de nós automática |
| **Busca** | O(log n) | Localiza elemento na árvore |
| **Remoção** | O(log n) | Remove elemento com merge de nós automático |
| **Espaço** | O(n) | Memória proporcional ao número de elementos |
| **Traversal Inorder** | O(n) | Percorre todos os elementos em ordem |

## Mecanismos Principais

### 1. Inserção (O(log n))

A inserção em uma árvore 2-3-4 segue um processo elegante:

1. **Descida Preventiva**: Ao descer pela árvore procurando o local de inserção, sempre que encontra um nó-4 (completo), divide-o em dois nó-2s
2. **Inserção na Folha**: Insere a nova chave na posição correta na folha encontrada
3. **Propagação Automática**: O nó-4 dividido propaga metade de suas chaves para o pai

**Vantagem**: Nunca precisa voltar acima para dividir, tudo é feito em uma única passagem descendente.

```
Antes de inserir 50 em uma árvore com nó-4 [30, 40, 50]:
         [30, 40, 50] ← Nó-4 (completo)
        /     |     |    \
       ...   ...   ...   ...

Ao encontrar nó-4, divide-o:
           [40]          ← Promove 40
          /    \
      [30]   [50]       ← Dois nó-2s
      /  \   /  \
     ...  ... ... ...
```

### 2. Busca (O(log n))

A busca é similar a uma BST, mas com múltiplas chaves por nó:

1. Começa na raiz
2. Compara o valor buscado com as chaves do nó
3. Se encontrado, retorna
4. Se não encontrado, desce pelo filho apropriado
5. Continua até encontrar ou chegar a uma folha

### 3. Remoção (O(log n))

A remoção é mais complexa e tem três casos:

**Caso 1: Chave em Folha**
- Simplesmente remove a chave
- Se folha fica com 0 chaves, faz merge com irmão

**Caso 2: Chave em Nó Interno**
- Se filho esquerdo tem ≥ 2 chaves: pega predecessor
- Se filho direito tem ≥ 2 chaves: pega sucessor
- Se ambos têm 1 chave: faz merge e remove do nó mesclado

**Caso 3: Necessidade de Merge**
- Se nó fica com 0 chaves, pede emprestado de irmão (sibling)
- Se irmão não pode emprestar (tem 1 chave), faz merge com irmão

```
Exemplo de Merge durante remoção:

Antes (removendo 35):
        [40]
       /    \
     [30, 35]  [50]

Depois (35 é parte de [30, 35], precisa de merge):
        [40]
       /    \
     [30]  [50]
     (ou mesclado dependendo do contexto)
```

## Aplicações Práticas

Árvores 2-3-4 são usadas em:

- **B-Trees Modernos**: Conceito base para B-Trees (grau > 2)
- **Banco de Dados**: Índices (MySQL, PostgreSQL) usam B-Trees derivados
- **Sistemas de Arquivos**: NTFS, ext4, HFS+ usam variações de B-Trees
- **Propósitos Educacionais**: Ensino de estruturas balanceadas
- **Implementações de Conjuntos Ordenados**: Quando simplicidade de código é importante

## Casos de Uso Ideais

Use Árvore 2-3-4 quando você:
- ✅ Quer entender fundamentos de B-Trees
- ✅ Precisa de rebalanceamento previsível e elegante
- ✅ Trabalha com inserções/remoções frequentes
- ✅ Quer minimizar rotações em estrutura balanceada
- ✅ Ensina ou aprende estruturas balanceadas

Evite quando:
- ❌ Precisa de máxima performance (Redis B-Trees com graus maiores)
- ❌ Apenas leitura (array ordenado é mais eficiente)
- ❌ Acesso por índice é crítico (use array)

## Anatomia de um Nó 2-3-4

```
┌─────────────────────────────────┐
│    Nó-4 com 3 chaves            │
├─────────────────────────────────┤
│  k₁ = 25    k₂ = 50   k₃ = 75   │
├──┬──────┬──────┬──────┬──────┬──┤
│ c₁│ c₂ │ c₃ │ c₄ │
└──┴──────┴──────┴──────┴──────┴──┘

Ranges:
  - Subtree c₁: valores < k₁ (< 25)
  - Subtree c₂: k₁ ≤ valor < k₂ (25 ≤ x < 50)
  - Subtree c₃: k₂ ≤ valor < k₃ (50 ≤ x < 75)
  - Subtree c₄: valores ≥ k₃ (≥ 75)
```

## Exemplo Completo de Inserção

Demonstrando como a árvore 2-3-4 evolui com inserções:

```
Passo 1: Inserir 50 (árvore vazia)
    [50]

Passo 2: Inserir 30
    [30, 50]

Passo 3: Inserir 70
    [30, 50, 70]   (nó-4)

Passo 4: Inserir 20 (força divisão)
    Detecta nó-4 [30, 50, 70], divide:
           [50]
          /    \
       [20, 30] [70]

Passo 5: Inserir 40
           [50]
          /    \
       [20, 30, 40] [70]  (agora esquerda é nó-4)

Passo 6: Inserir 60 (força novo balanceamento)
    Desce, detecta filho direito é folha [70]
    Insere 60:
           [50]
          /    \
    [20, 30, 40] [60, 70]

Passo 7: Inserir 10 (força divisão em cascata)
    Desce esquerda [20, 30, 40] (nó-4!)
    Divide:
          [30, 50]
         /   |    \
      [20]  [40] [60, 70]
    
    Insere 10:
          [30, 50]
         /   |    \
    [10, 20] [40] [60, 70]
```

## Complexidade Detalhada

### Análise de Altura

Para uma árvore 2-3-4 com n elementos:
- **Altura mínima**: log₄(n+1) - quando todos os nós são 4s
- **Altura máxima**: log₂(n+1) - quando todos os nós são 2s
- **Na prática**: h = O(log n)

### Análise de Tempo

| Operação | Comparações | Atualizações | Divisões/Merges |
|----------|-------------|--------------|-----------------|
| Inserção | O(log n) | O(log n) | O(1) amortizado |
| Busca | O(log n) | - | - |
| Remoção | O(log n) | O(log n) | O(log n) |

### Análise de Espaço

- **Espaço por nó**: O(1) - máximo 3 chaves, 4 ponteiros
- **Espaço total**: O(n) - n elementos em n/2 a n nós
- **Overhead**: ~2n ponteiros + n chaves = O(n)

## Visualização e Debugging

A árvore 2-3-4 implementada fornece:

```python
# Visualizar árvore com Graphviz
tree.visualize(filename="minha_arvore")

# Pretty print no console
tree.pretty_print()

# Traversal em ordem
for valor in tree.traverse():
    print(valor)
```

## Implementação Prática

A implementação incluída neste projeto oferece:

1. **Classe BTreeNode**: Representa um nó da árvore
   - Suporta 1-3 chaves
   - Mantém até 4 filhos
   - Operações de comparação e busca

2. **Classe BTree234**: Árvore completa
   - Insert com divisão automática
   - Delete com merge automático
   - Search eficiente
   - Visualização com Graphviz

3. **Classe BTree234Session**: Interface interativa
   - Menu de 6 opções
   - Logging de operações
   - Visualização antes/depois
   - Salva arquivos PNG

## Diferenças: 2-3-4 vs Red-Black Tree

| Aspecto | 2-3-4 | Red-Black |
|---------|-------|-----------|
| **Estrutura** | Multi-chave (1-3) | Binária com cores |
| **Balanceamento** | Divisão de nós | Rotações + recoloração |
| **Inserção** | Descida preventiva | Ascensão com ajustes |
| **Remoção** | Merge de nós | Casos complexos |
| **Intuição** | Mais intuitiva | Mais abstrata (cores) |
| **Aplicações** | Educacional, B-Trees | Sistemas reais |
| **Performance** | O(log n) | O(log n) |

## Conclusão

A Árvore 2-3-4 é uma estrutura fundamental para compreender:
- **B-Trees modernos**: Base teórica
- **Rebalanceamento elegante**: Alternativa a rotações
- **Projeto de estruturas**: Como balancear sem complexidade excessiva
- **Conceitos de banco de dados**: Índices e organização

Embora menos utilizada em produção que Red-Black Trees (que têm apenas 2 filhos por nó), a 2-3-4 é superior em clareza conceitual e serve como trampolim perfeito entre árvores simples (BST) e estruturas complexas (B-Trees com graus variáveis).

## Referências

- **Bayer, R.** (1970). "Binary B-Trees for Virtual Memory"
- **Sedgewick & Wayne** (2011). "Algorithms, 4th Edition" - Seção 3.3
- **Cormen, Leiserson, Rivest & Stein** (2009). "Introduction to Algorithms" - Capítulo 18
- **Wikipedia**: B-Tree article com referências adicionais
